[TextureSource]

shader RCUnity_TextureFX : TextureFX
{
    // Multi-pass radiance cascade â€” closely follows Unity RadianceCascades2DGI.shader
    //
    // Texture0: Scene RGBA (RGB = emissive color)
    // Texture1: Distance field (from JFA pipeline)
    // Texture2: Parent cascade output (previous pass, or black for top cascade)
    //
    // NOTE: Resolution must be power-of-2 (e.g., 512, 1024, 2048)

    SamplerState ClampPointSampler
    {
        Filter = MIN_MAG_MIP_POINT;
        AddressU = Clamp;
        AddressV = Clamp;
    };
    SamplerState ClampLinearSampler
    {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Clamp;
        AddressV = Clamp;
    };

    float2 R = ViewSize;

    int CascadeLevel = 0;
    int NumCascades = 6;
    float RayRange = 1.0;
    int MarchSteps = 64;

    #define TAU 6.28318530718

    float2 CalculateRayRange(uint idx, uint count)
    {
        // Compute effective ray range matching Unity:
        // _RayRange = magnitude(screen / min(screen.x, screen.y)) * userRayRange
        float minR = min(R.x, R.y);
        float2 normalizedScreen = R / minR;
        float effectiveRayRange = length(normalizedScreen) * RayRange;

        float maxValue = float((1 << (count * 2)) - 1);
        float rangeStart = float((1 << (idx * 2)) - 1);
        float rangeEnd = float((1 << (idx * 2 + 2)) - 1);
        return float2(rangeStart, rangeEnd) / maxValue * effectiveRayRange;
    }

    float4 SampleRadianceSDF(float2 rayOrigin, float2 rayDirection, float2 rayRange)
    {
        float mxR = max(R.x, R.y);
        float2 aspectYX = float2(R.y, R.x) / mxR;
        float t = rayRange.x;
        float4 hit = float4(0, 0, 0, 1);

        for (int i = 0; i < MarchSteps; i++)
        {
            float2 currentPosition = rayOrigin + t * rayDirection * aspectYX;

            if (t > rayRange.y
                || currentPosition.x < 0 || currentPosition.y < 0
                || currentPosition.x > 1 || currentPosition.y > 1)
            {
                break;
            }

            float dist = Texture1.SampleLevel(ClampLinearSampler, currentPosition, 0).r;

            if (dist < 0.001)
            {
                hit = float4(Texture0.SampleLevel(ClampLinearSampler, currentPosition, 0).rgb, 0);
                break;
            }

            t += dist;
        }

        return hit;
    }

    stage override float4 Shading()
    {
        float2 pixelIndex = floor(streams.TexCoord * R);

        int blockSqrt = 1 << CascadeLevel;

        float2 blockDim = R / float(blockSqrt);
        float2 block2DIndex = floor(pixelIndex / blockDim);
        float blockIndex = block2DIndex.x + block2DIndex.y * float(blockSqrt);

        float2 coordsInBlock = fmod(pixelIndex, blockDim);

        float4 finalResult = float4(0, 0, 0, 0);

        float2 rayOrigin = (coordsInBlock + 0.5) * float(blockSqrt) / R;
        float2 range = CalculateRayRange(CascadeLevel, NumCascades);

        for (int i = 0; i < 4; i++)
        {
            float angleStep = TAU / float(blockSqrt * blockSqrt * 4);
            float angleIndex = blockIndex * 4.0 + float(i);
            float angle = (angleIndex + 0.5) * angleStep;

            float2 rayDirection = float2(cos(angle), sin(angle));

            float4 radiance = SampleRadianceSDF(rayOrigin, rayDirection, range);

            if (radiance.a != 0.0)
            {
                if (CascadeLevel < NumCascades - 1)
                {
                    float2 position = coordsInBlock * 0.5 + 0.25;
                    float2 positionOffset = float2(
                        fmod(angleIndex, float(blockSqrt * 2)),
                        floor(angleIndex / float(blockSqrt * 2))
                    );

                    position = clamp(position, 0.5, blockDim * 0.5 - 0.5);

                    float2 mergeUV = (position + positionOffset * blockDim * 0.5) / R;
                    float4 rad = Texture2.SampleLevel(ClampLinearSampler, mergeUV, 0);

                    radiance.rgb += rad.rgb * radiance.a;
                    radiance.a *= rad.a;
                }
            }

            finalResult += radiance * 0.25;
        }

        return finalResult;
    }
};
