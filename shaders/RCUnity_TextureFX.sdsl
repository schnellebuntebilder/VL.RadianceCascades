[TextureSource]

shader RCUnity_TextureFX : TextureFX
{
    // Multi-pass radiance cascade — closely follows Unity RadianceCascades2DGI.shader
    //
    // Texture0: Scene RGBA (RGB = emissive color)
    // Texture1: Distance field (from JFA pipeline)
    // Texture2: Parent cascade output (previous pass, or black for top cascade)

    float2 R = ViewSize;

    int CascadeLevel = 0;
    int NumCascades = 4;
    float RayRange = 1.0;
    int MarchSteps = 32;

    #define TAU 6.28318530718

    float2 CalculateRayRange(uint idx, uint count)
    {
        float maxValue = float((1 << (count * 2)) - 1);
        float rangeStart = float((1 << (idx * 2)) - 1);
        float rangeEnd = float((1 << (idx * 2 + 2)) - 1);
        return float2(rangeStart, rangeEnd) / maxValue * RayRange;
    }

    // Safe point sample with UV clamping to prevent Wrap bleeding
    float4 SampleClamped(Texture2D tex, float2 uv)
    {
        uv = clamp(uv, 0.5 / R, 1.0 - 0.5 / R);
        return tex.SampleLevel(Sampler0, uv, 0);
    }

    // Manual bilinear with clamped point samples — avoids Wrap bleed
    float4 SampleBilinearClamped(Texture2D tex, float2 uv)
    {
        float2 texelSize = 1.0 / R;
        float2 texelPos = uv * R - 0.5;
        float2 f = frac(texelPos);
        float2 baseUV = (floor(texelPos) + 0.5) * texelSize;

        float4 s00 = SampleClamped(tex, baseUV);
        float4 s10 = SampleClamped(tex, baseUV + float2(texelSize.x, 0));
        float4 s01 = SampleClamped(tex, baseUV + float2(0, texelSize.y));
        float4 s11 = SampleClamped(tex, baseUV + texelSize);

        return lerp(lerp(s00, s10, f.x), lerp(s01, s11, f.x), f.y);
    }

    float4 SampleRadianceSDF(float2 rayOrigin, float2 rayDirection, float2 rayRange)
    {
        float mxR = max(R.x, R.y);
        float2 aspectYX = float2(R.y, R.x) / mxR;
        float t = rayRange.x;
        float4 hit = float4(0, 0, 0, 1);

        for (int i = 0; i < MarchSteps; i++)
        {
            float2 currentPosition = rayOrigin + t * rayDirection * aspectYX;

            if (t > rayRange.y
                || currentPosition.x <= 0 || currentPosition.y <= 0
                || currentPosition.x >= 1 || currentPosition.y >= 1)
            {
                break;
            }

            float dist = SampleClamped(Texture1, currentPosition).r;

            if (dist < 0.001)
            {
                hit = float4(SampleClamped(Texture0, currentPosition).rgb, 0);
                break;
            }

            t += dist;
        }

        return hit;
    }

    stage override float4 Shading()
    {
        float2 pixelIndex = min(floor(streams.TexCoord * R), R - 1);

        int blockSqrt = 1 << CascadeLevel;

        float2 blockDim = R / float(blockSqrt);
        float2 block2DIndex = floor(pixelIndex / blockDim);
        float blockIndex = block2DIndex.x + block2DIndex.y * float(blockSqrt);

        float2 coordsInBlock = fmod(pixelIndex, blockDim);

        float4 finalResult = float4(0, 0, 0, 0);

        float2 rayOrigin = (coordsInBlock + 0.5) * float(blockSqrt) / R;
        float2 range = CalculateRayRange(CascadeLevel, NumCascades);

        for (int i = 0; i < 4; i++)
        {
            float angleStep = TAU / float(blockSqrt * blockSqrt * 4);
            float angleIndex = blockIndex * 4.0 + float(i);
            float angle = (angleIndex + 0.5) * angleStep;

            float2 rayDirection = float2(cos(angle), sin(angle));

            float4 radiance = SampleRadianceSDF(rayOrigin, rayDirection, range);

            if (radiance.a != 0.0)
            {
                if (CascadeLevel < NumCascades - 1)
                {
                    float2 position = coordsInBlock * 0.5 + 0.25;
                    float2 positionOffset = float2(
                        fmod(angleIndex, float(blockSqrt * 2)),
                        floor(angleIndex / float(blockSqrt * 2))
                    );

                    position = clamp(position, 0.5, blockDim * 0.5 - 0.5);

                    float2 mergeUV = (position + positionOffset * blockDim * 0.5) / R;
                    float4 rad = SampleBilinearClamped(Texture2, mergeUV);

                    radiance.rgb += rad.rgb * radiance.a;
                    radiance.a *= rad.a;
                }
            }

            finalResult += radiance * 0.25;
        }

        return finalResult;
    }
};
