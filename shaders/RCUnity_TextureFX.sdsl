[TextureSource]

shader RCUnity_TextureFX : TextureFX
{
    // Multi-pass radiance cascade — closely follows Unity RadianceCascades2DGI.shader
    //
    // Texture0: Scene RGBA (RGB = emissive color)
    // Texture1: Distance field (from JFA pipeline)
    // Texture2: Parent cascade output (previous pass, or black for top cascade)

    SamplerState ClampPointSampler
    {
        Filter = MIN_MAG_MIP_POINT;
        AddressU = Clamp;
        AddressV = Clamp;
    };
    SamplerState ClampLinearSampler
    {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Clamp;
        AddressV = Clamp;
    };

    float2 R = ViewSize;

    int CascadeLevel = 0;
    int NumCascades = 4;
    float RayRange = 1.0;
    int MarchSteps = 32;
    bool DisableMerge = false;
    bool DebugMergeUV = false;
    bool DebugMergeSample = false;
    bool UsePointMerge = false;
    // Debug: 0=off, 1=show Texture2 at own UV, 2=show rayOrigin as color, 3=show range
    int DebugMode = 0;

    #define TAU 6.28318530718

    float2 CalculateRayRange(uint idx, uint count)
    {
        float maxValue = float((1 << (count * 2)) - 1);
        float rangeStart = float((1 << (idx * 2)) - 1);
        float rangeEnd = float((1 << (idx * 2 + 2)) - 1);
        return float2(rangeStart, rangeEnd) / maxValue * RayRange;
    }

    float4 SampleRadianceSDF(float2 rayOrigin, float2 rayDirection, float2 rayRange)
    {
        float mxR = max(R.x, R.y);
        float2 aspectYX = float2(R.y, R.x) / mxR;
        float t = rayRange.x;
        float4 hit = float4(0, 0, 0, 1);

        for (int i = 0; i < MarchSteps; i++)
        {
            float2 currentPosition = rayOrigin + t * rayDirection * aspectYX;

            if (t > rayRange.y
                || currentPosition.x < 0 || currentPosition.y < 0
                || currentPosition.x > 1 || currentPosition.y > 1)
            {
                break;
            }

            float dist = Texture1.SampleLevel(ClampPointSampler, currentPosition, 0).r;

            if (dist < 0.001)
            {
                hit = float4(Texture0.SampleLevel(ClampPointSampler, currentPosition, 0).rgb, 0);
                break;
            }

            t += dist;
        }

        return hit;
    }

    stage override float4 Shading()
    {
        // Snap effective resolution to largest multiple of max blockSqrt
        int maxBlockSqrt = 1 << (NumCascades - 1);
        float2 effectiveR = floor(R / float(maxBlockSqrt)) * float(maxBlockSqrt);

        float2 pixelIndex = min(floor(streams.TexCoord * R), R - 1);
        // Clamp pixels to effective area
        pixelIndex = min(pixelIndex, effectiveR - 1);

        int blockSqrt = 1 << CascadeLevel;

        float2 blockDim = effectiveR / float(blockSqrt);
        float2 block2DIndex = floor(pixelIndex / blockDim);
        float blockIndex = block2DIndex.x + block2DIndex.y * float(blockSqrt);

        float2 coordsInBlock = pixelIndex - block2DIndex * blockDim;

        // Early-out debug modes
        if (DebugMode == 1)
        {
            // Show raw Texture2 at this pixel's own UV
            return Texture2.SampleLevel(ClampPointSampler, streams.TexCoord, 0);
        }
        if (DebugMode == 2)
        {
            // Show rayOrigin — should be smooth gradient 0..1 within each block
            float2 rayOrig = (coordsInBlock + 0.5) * float(blockSqrt) / R;
            return float4(rayOrig, 0, 1);
        }
        if (DebugMode == 3)
        {
            // Show ray range for this cascade level
            float2 rng = CalculateRayRange(CascadeLevel, NumCascades);
            return float4(rng.x, rng.y, 0, 1);
        }
        if (DebugMode == 4)
        {
            // Show blockIndex as hue per block
            return float4(block2DIndex.x / float(blockSqrt), block2DIndex.y / float(blockSqrt), float(CascadeLevel) / float(NumCascades), 1);
        }
        if (DebugMode == 5)
        {
            // Show coordsInBlock normalized — should be smooth 0..1 gradient in each block
            return float4(coordsInBlock / blockDim, 0, 1);
        }
        if (DebugMode == 6)
        {
            float2 position = coordsInBlock * 0.5 + 0.25;
            float firstAngleIndex = blockIndex * 4.0;
            float2 positionOffset = float2(
                fmod(firstAngleIndex, float(blockSqrt * 2)),
                floor(firstAngleIndex / float(blockSqrt * 2))
            );
            position = clamp(position, 0.5, blockDim * 0.5 - 0.5);
            float2 mergeUV = (position + positionOffset * blockDim * 0.5) / effectiveR;
            return Texture2.SampleLevel(ClampPointSampler, mergeUV, 0);
        }
        if (DebugMode == 7)
        {
            float2 position = coordsInBlock * 0.5 + 0.25;
            float firstAngleIndex = blockIndex * 4.0;
            float2 positionOffset = float2(
                fmod(firstAngleIndex, float(blockSqrt * 2)),
                floor(firstAngleIndex / float(blockSqrt * 2))
            );
            position = clamp(position, 0.5, blockDim * 0.5 - 0.5);
            float2 mergeUV = (position + positionOffset * blockDim * 0.5) / effectiveR;
            float oob = (mergeUV.x < 0 || mergeUV.x > 1 || mergeUV.y < 0 || mergeUV.y > 1) ? 1.0 : 0.0;
            return float4(mergeUV, oob, 1);
        }
        if (DebugMode == 8)
        {
            // Show just raymarched radiance for all 4 dirs, NO merge
            float4 res = float4(0,0,0,0);
            float2 ro = (coordsInBlock + 0.5) * float(blockSqrt) / R;
            float2 rng = CalculateRayRange(CascadeLevel, NumCascades);
            for (int d = 0; d < 4; d++)
            {
                float as2 = TAU / float(blockSqrt * blockSqrt * 4);
                float ai = blockIndex * 4.0 + float(d);
                float a = (ai + 0.5) * as2;
                float2 rd = float2(cos(a), sin(a));
                float4 rad = SampleRadianceSDF(ro, rd, rng);
                res += rad * 0.25;
            }
            return res;
        }

        float4 finalResult = float4(0, 0, 0, 0);

        float2 rayOrigin = (coordsInBlock + 0.5) * float(blockSqrt) / R;
        float2 range = CalculateRayRange(CascadeLevel, NumCascades);

        for (int i = 0; i < 4; i++)
        {
            float angleStep = TAU / float(blockSqrt * blockSqrt * 4);
            float angleIndex = blockIndex * 4.0 + float(i);
            float angle = (angleIndex + 0.5) * angleStep;

            float2 rayDirection = float2(cos(angle), sin(angle));

            float4 radiance = SampleRadianceSDF(rayOrigin, rayDirection, range);

            if (radiance.a != 0.0)
            {
                if (!DisableMerge && CascadeLevel < NumCascades - 1)
                {
                    float2 position = coordsInBlock * 0.5 + 0.25;
                    float2 positionOffset = float2(
                        fmod(angleIndex, float(blockSqrt * 2)),
                        floor(angleIndex / float(blockSqrt * 2))
                    );

                    position = clamp(position, 0.5, blockDim * 0.5 - 0.5);

                    float2 mergeUV = (position + positionOffset * blockDim * 0.5) / effectiveR;

                    if (DebugMergeUV)
                    {
                        finalResult += float4(mergeUV, 0, 1) * 0.25;
                        continue;
                    }

                    float4 rad;
                    if (UsePointMerge)
                        rad = Texture2.SampleLevel(ClampPointSampler, mergeUV, 0);
                    else
                        rad = Texture2.SampleLevel(ClampLinearSampler, mergeUV, 0);

                    if (DebugMergeSample)
                    {
                        // Show what we actually read from the parent
                        finalResult += rad * 0.25;
                        continue;
                    }

                    radiance.rgb += rad.rgb * radiance.a;
                    radiance.a *= rad.a;
                }
            }

            finalResult += radiance * 0.25;
        }

        return finalResult;
    }
};
