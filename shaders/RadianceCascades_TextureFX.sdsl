[TextureSource]
[WantsMips("Texture0")]

shader RadianceCascades_TextureFX : TextureFX
{
    // Texture0: Scene RGBA - RGB = emissive color
    // Texture1: SDF - signed distance field

    float2 R = ViewSize;

    int NumBaseDirections = 8;
    int MarchSteps = 16;
    int NumCascades = 4;
    float MaxDistance = 1.0;
    float SDFScale = 1.0;
    float Exposure = 1.0;
    float BlendWidth = 1.0;
    float RayOffset = 2.0;
    float MipScale = 0.25;
    float SmoothScale = 4.0;

    #define TAU 6.28318530718

    float hash(float2 p)
    {
        return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
    }

    float2 SnapToGrid(float2 uv, float cellPixels)
    {
        float2 cell = cellPixels / R;
        return (floor(uv / cell) + 0.5) * cell;
    }

    float2 CascadeRange(int index)
    {
        float maxVal = float((1 << (NumCascades * 2)) - 1);
        float s = float((1 << (index * 2)) - 1);
        float e = float((1 << (index * 2 + 2)) - 1);
        return float2(s, e) / maxVal * MaxDistance;
    }

    // AABB ray intersection — returns [tEnter, tExit] for ray vs [0,1]² screen bounds
    float2 IntersectAABB(float2 ro, float2 rd)
    {
        float2 tA = (0.0001 - ro) / rd;
        float2 tB = (0.9999 - ro) / rd;
        float2 t1 = min(tA, tB);
        float2 t2 = max(tA, tB);
        float tEnter = max(t1.x, t1.y);
        float tExit = min(t2.x, t2.y);
        return tEnter > tExit ? float2(-1, -1) : float2(tEnter, tExit);
    }

    // Trace a ray through a cascade interval.
    // Returns float4(radiance * fade, visibility).
    float4 TraceInterval(float2 origin, float2 rd, float2 range, int cascadeIndex)
    {
        float pixelSize = 1.0 / max(R.x, R.y);
        float hitThreshold = pixelSize;

        float sMin = float(1 << cascadeIndex) * SmoothScale * pixelSize;
        float sMax = float(1 << (cascadeIndex + 1)) * SmoothScale * pixelSize;
        float tMin = range.x - sMin * 0.5;
        float tMax = range.y + sMax * 0.5;
        float tStart = max(hitThreshold * RayOffset, tMin);

        // Clip ray to screen bounds — skip rays that miss entirely
        // and advance start to screen edge if origin is near border
        float2 tAABB = IntersectAABB(origin, rd);
        if (tAABB.x > tMax || tAABB.y < tStart)
            return float4(0, 0, 0, 1);

        if (tAABB.x > tStart)
            tStart = tAABB.x;
        if (tAABB.y < tMax)
            tMax = tAABB.y;

        float t = tStart;

        for (int s = 0; s < MarchSteps; s++)
        {
            float2 p = origin + t * rd;

            float sdf = Texture1.SampleLevel(Sampler0, p, 0).r * SDFScale;

            // Refined hit detection: require minimum travel distance
            // before accepting a hit, and use a looser distance check
            // to avoid missing glancing surfaces
            if (t > tStart + pixelSize && sdf < 1.0 * pixelSize)
            {
                float mip = log2(1.0 + t * max(R.x, R.y)) * MipScale;
                float3 hitColor = Texture0.SampleLevel(Sampler0, p, mip).rgb;

                float fadeIn = saturate((t - tMin) / max(sMin, pixelSize));
                float fadeOut = saturate((tMax - t) / max(sMax, pixelSize));
                float fade = fadeIn * fadeOut;

                return float4(hitColor * fade, 1.0 - fade);
            }

            t += abs(sdf);

            if (t >= tMax)
                break;
        }

        return float4(0, 0, 0, 1);
    }

    // Trace from a probe origin for all cascades along one base direction.
    float3 TraceProbe(float2 uv, float baseAngle, float angularCell, float aspect)
    {
        float3 parentRadiance = 0;

        for (int c = NumCascades - 1; c >= 0; c--)
        {
            float2 range = CascadeRange(c);
            float cellSize = float(1 << c);
            float2 probeUV = c == 0 ? uv : SnapToGrid(uv, cellSize);

            if (c == 0)
            {
                float2 rd = normalize(float2(cos(baseAngle) / aspect, sin(baseAngle)));
                float4 result = TraceInterval(uv, rd, range, c);
                parentRadiance = result.rgb + result.a * parentRadiance;
            }
            else
            {
                float3 cascadeRad = 0;

                for (int i = 0; i < 4; i++)
                {
                    float subAngle = baseAngle + ((float(i) + 0.5) / 4.0 - 0.5) * angularCell;
                    float2 rd = normalize(float2(cos(subAngle) / aspect, sin(subAngle)));

                    float4 result = TraceInterval(probeUV, rd, range, c);
                    cascadeRad += result.rgb + result.a * parentRadiance;
                }

                parentRadiance = cascadeRad * 0.25;
            }
        }

        return parentRadiance;
    }

    stage override float4 Shading()
    {
        float2 uv = streams.TexCoord;
        float aspect = R.x / R.y;
        float pixelSize = 1.0 / max(R.x, R.y);

        float originSDF = Texture1.SampleLevel(Sampler0, uv, 0).r * SDFScale;
        float jitter = hash(uv * R) * TAU;

        float3 totalRadiance = 0;
        float angularCell = TAU / float(NumBaseDirections);

        for (int d = 0; d < NumBaseDirections; d++)
        {
            float baseAngle = (float(d) + 0.5) / float(NumBaseDirections) * TAU + jitter;
            totalRadiance += TraceProbe(uv, baseAngle, angularCell, aspect);
        }

        totalRadiance /= float(NumBaseDirections);
        totalRadiance *= TAU;

        // Blend direct emissive near surfaces
        float3 selfColor = Texture0.SampleLevel(Sampler0, uv, 0).rgb;
        float blend = saturate(1.0 - originSDF * max(R.x, R.y) * BlendWidth);
        totalRadiance = lerp(totalRadiance, selfColor * TAU, blend);
        totalRadiance = max(totalRadiance, selfColor * TAU * blend * blend);

        // Tonemapping
        totalRadiance *= Exposure;
        float3 mapped = 1.0 - 1.0 / pow(1.0 + totalRadiance, 2.5);

        return float4(mapped, 1.0);
    }
};
