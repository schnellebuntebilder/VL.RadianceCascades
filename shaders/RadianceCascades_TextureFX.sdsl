[TextureSource]
[WantsMips("Texture0")]

shader RadianceCascades_TextureFX : TextureFX
{
    // Texture0: Scene RGBA - RGB = emissive color
    // Texture1: SDF - signed distance field

    float2 R = ViewSize;

    int NumBaseDirections = 8;
    int MarchSteps = 16;
    int NumCascades = 4;
    float MaxDistance = 1.0;
    float SDFScale = 1.0;
    float Exposure = 1.0;
    float BlendWidth = 1.0;
    float RayOffset = 2.0;
    float MipScale = 0.25;
    float SmoothScale = 4.0;

    float SkyRadiance = 0.0;
    float3 SkyColor = float3(0.2, 0.5, 1.0);
    float3 SunColor = float3(1.0, 0.7, 0.1);
    float SunAngle = 2.0;

    #define TAU 6.28318530718
    #define PI 3.14159265359

    float hash(float2 p)
    {
        return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
    }

    float2 SnapToGrid(float2 uv, float cellPixels)
    {
        float2 cell = cellPixels / R;
        return (floor(uv / cell) + 0.5) * cell;
    }

    float2 CascadeRange(int index)
    {
        float maxVal = float((1 << (NumCascades * 2)) - 1);
        float s = float((1 << (index * 2)) - 1);
        float e = float((1 << (index * 2 + 2)) - 1);
        return float2(s, e) / maxVal * MaxDistance;
    }

    // Analytical sky radiance integrated over an angular interval [a0, a1]
    float3 IntegrateSkyRadiance(float a0, float a1)
    {
        float SSunS = 8.0;
        float ISSunS = 1.0 / SSunS;
        float3 SI = SkyColor * (a1 - a0 - 0.5 * (cos(a1) - cos(a0)));
        SI += SunColor * (atan(SSunS * (SunAngle - a0)) - atan(SSunS * (SunAngle - a1))) * ISSunS;
        return SI * 0.16;
    }

    // Trace a ray through a cascade interval.
    // Returns float4(radiance * fade, visibility).
    float4 TraceInterval(float2 origin, float2 rd, float2 range, int cascadeIndex)
    {
        float pixelSize = 1.0 / max(R.x, R.y);
        float hitThreshold = pixelSize;

        float sMin = float(1 << cascadeIndex) * SmoothScale * pixelSize;
        float sMax = float(1 << (cascadeIndex + 1)) * SmoothScale * pixelSize;
        float tMin = range.x - sMin * 0.5;
        float tMax = range.y + sMax * 0.5;
        float tStart = max(hitThreshold * RayOffset, tMin);

        float t = tStart;

        for (int s = 0; s < MarchSteps; s++)
        {
            float2 p = origin + t * rd;

            if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)
                break;

            float sdf = Texture1.SampleLevel(Sampler0, p, 0).r * SDFScale;

            if (sdf <= hitThreshold)
            {
                float mip = log2(1.0 + t * max(R.x, R.y)) * MipScale;
                float3 hitColor = Texture0.SampleLevel(Sampler0, p, mip).rgb;

                float fadeIn = saturate((t - tMin) / max(sMin, pixelSize));
                float fadeOut = saturate((tMax - t) / max(sMax, pixelSize));
                float fade = fadeIn * fadeOut;

                return float4(hitColor * fade, 1.0 - fade);
            }

            t += sdf;

            if (t >= tMax)
                break;
        }

        return float4(0, 0, 0, 1);
    }

    // Trace from a single probe origin for all cascades along one base direction.
    // Returns merged radiance including sky at top cascade.
    float3 TraceProbe(float2 probeOrigin, float2 uv, float baseAngle, float angularCell, float aspect)
    {
        float3 parentRadiance = 0;

        for (int c = NumCascades - 1; c >= 0; c--)
        {
            float2 range = CascadeRange(c);

            if (c == 0)
            {
                float2 rd = normalize(float2(cos(baseAngle) / aspect, sin(baseAngle)));
                float4 result = TraceInterval(uv, rd, range, c);
                parentRadiance = result.rgb + result.a * parentRadiance;
            }
            else
            {
                float3 cascadeRad = 0;

                for (int i = 0; i < 4; i++)
                {
                    float subAngle = baseAngle + ((float(i) + 0.5) / 4.0 - 0.5) * angularCell;
                    float2 rd = normalize(float2(cos(subAngle) / aspect, sin(subAngle)));

                    float4 result = TraceInterval(probeOrigin, rd, range, c);

                    if (c == NumCascades - 1)
                    {
                        // Top cascade: merge with analytical sky radiance
                        float angleStep = angularCell / 4.0;
                        float3 sky = IntegrateSkyRadiance(subAngle, subAngle + angleStep) / angleStep;
                        float3 merged = result.rgb + result.a * sky * SkyRadiance;
                        cascadeRad += merged;
                    }
                    else
                    {
                        cascadeRad += result.rgb + result.a * parentRadiance;
                    }
                }

                parentRadiance = cascadeRad * 0.25;
            }
        }

        return parentRadiance;
    }

    stage override float4 Shading()
    {
        float2 uv = streams.TexCoord;
        float aspect = R.x / R.y;
        float pixelSize = 1.0 / max(R.x, R.y);

        float originSDF = Texture1.SampleLevel(Sampler0, uv, 0).r * SDFScale;
        float jitter = hash(uv * R) * TAU;

        float3 totalRadiance = 0;
        float angularCell = TAU / float(NumBaseDirections);

        for (int d = 0; d < NumBaseDirections; d++)
        {
            float baseAngle = (float(d) + 0.5) / float(NumBaseDirections) * TAU + jitter;

            // Bilinear probe interpolation: sample the 4 nearest coarse
            // probes and blend results, eliminating grid discontinuities.
            float cellPixels = float(1 << (NumCascades - 1));
            float2 cell = cellPixels / R;
            float2 probeF = uv / cell - 0.5;
            float2 probeI = floor(probeF);
            float2 w = probeF - probeI;

            float3 r00 = TraceProbe((probeI + float2(0.5, 0.5)) * cell, uv, baseAngle, angularCell, aspect);
            float3 r10 = TraceProbe((probeI + float2(1.5, 0.5)) * cell, uv, baseAngle, angularCell, aspect);
            float3 r01 = TraceProbe((probeI + float2(0.5, 1.5)) * cell, uv, baseAngle, angularCell, aspect);
            float3 r11 = TraceProbe((probeI + float2(1.5, 1.5)) * cell, uv, baseAngle, angularCell, aspect);

            float3 blended = lerp(lerp(r00, r10, w.x), lerp(r01, r11, w.x), w.y);

            totalRadiance += blended;
        }

        totalRadiance /= float(NumBaseDirections);
        totalRadiance *= TAU;

        // Blend direct emissive near surfaces
        float3 selfColor = Texture0.SampleLevel(Sampler0, uv, 0).rgb;
        float blend = saturate(1.0 - originSDF * max(R.x, R.y) * BlendWidth);
        totalRadiance = lerp(totalRadiance, selfColor * TAU, blend);
        totalRadiance = max(totalRadiance, selfColor * TAU * blend * blend);

        // Tonemapping
        totalRadiance *= Exposure;
        float3 mapped = 1.0 - 1.0 / pow(1.0 + totalRadiance, 2.5);

        return float4(mapped, 1.0);
    }
};
