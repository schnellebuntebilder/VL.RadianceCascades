[TextureSource]
[WantsMips("Texture0")]

shader RadianceCascades_TextureFX : TextureFX
{
    // Texture0: Scene RGBA - RGB = emissive color
    // Texture1: SDF - signed distance field (positive = outside, <=0 = surface)

    float2 R = ViewSize;

    int NumDirections = 64;
    int MarchSteps = 64;
    float MaxDistance = 0.5;
    float SDFScale = 1.0;
    float Exposure = 1.0;
    float BlendWidth = 0.1;
    float RayOffset = 2.0;
    float MipScale = 0.25;

    #define TAU 6.28318530718

    float hash(float2 p)
    {
        return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
    }

    stage override float4 Shading()
    {
        float2 uv = streams.TexCoord;
        float aspect = R.x / R.y;
        float pixelSize = 1.0 / max(R.x, R.y);
        float hitThreshold = pixelSize;

        float originSDF = Texture1.SampleLevel(Sampler0, uv, 0).r * SDFScale;

        float jitter = hash(uv * R) * TAU;

        float3 totalRadiance = 0;

        for (int d = 0; d < NumDirections; d++)
        {
            float angle = (float(d) + 0.5) / float(NumDirections) * TAU + jitter;
            float2 rd = normalize(float2(cos(angle) / aspect, sin(angle)));

            float t = hitThreshold * RayOffset;

            for (int s = 0; s < MarchSteps; s++)
            {
                float2 p = uv + t * rd;

                if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)
                    break;

                float sdf = Texture1.SampleLevel(Sampler0, p, 0).r * SDFScale;

                if (sdf <= hitThreshold)
                {
                    // Mip level scales with distance for smooth far-field.
                    // MipScale controls the tradeoff: higher = smoother but
                    // may bleed light through thin occluders.
                    float mip = log2(1.0 + t * max(R.x, R.y)) * MipScale;
                    totalRadiance += Texture0.SampleLevel(Sampler0, p, mip).rgb;
                    break;
                }

                t += sdf;

                if (t >= MaxDistance)
                    break;
            }
        }

        totalRadiance /= float(NumDirections);
        totalRadiance *= TAU;

        // Approach 1: Blend direct emissive using SDF distance
        float3 selfColor = Texture0.SampleLevel(Sampler0, uv, 0).rgb;
        float blend = saturate(1.0 - originSDF * max(R.x, R.y) * BlendWidth);
        totalRadiance = lerp(totalRadiance, selfColor * TAU, blend);

        // Approach 2: Ensure no black gap â€” near emitters, enforce minimum
        totalRadiance = max(totalRadiance, selfColor * TAU * blend * blend);

        // Tonemapping (matches shadertoy reference)
        totalRadiance *= Exposure;
        float3 mapped = 1.0 - 1.0 / pow(1.0 + totalRadiance, 2.5);

        return float4(mapped, 1.0);
    }
};
