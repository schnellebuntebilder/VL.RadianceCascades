[TextureSource]

shader RadianceCascades_TextureFX : TextureFX
{
    // Texture0: Scene RGBA - RGB = emissive color
    // Texture1: SDF - signed distance field (positive = outside, <=0 = surface)

    float2 R = ViewSize;

    int NumDirections = 32;
    int MarchSteps = 64;
    float MaxDistance = 0.5;
    float SDFScale = 1.0;
    float Exposure = 1.0;
    int GatherRadius = 1;

    #define TAU 6.28318530718

    float hash(float2 p)
    {
        return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
    }

    // Trace rays for a single pixel and return average radiance
    float3 TracePixel(float2 uv, float aspect, float pixelSize, float hitThreshold, float jitter)
    {
        float3 rad = 0;

        for (int d = 0; d < NumDirections; d++)
        {
            float angle = (float(d) + 0.5) / float(NumDirections) * TAU + jitter;
            float2 rd = normalize(float2(cos(angle) / aspect, sin(angle)));

            float t = hitThreshold * 2.0;

            for (int s = 0; s < MarchSteps; s++)
            {
                float2 p = uv + t * rd;

                if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)
                    break;

                float sdf = Texture1.SampleLevel(Sampler0, p, 0).r * SDFScale;

                if (sdf <= hitThreshold)
                {
                    rad += Texture0.SampleLevel(Sampler0, p, 0).rgb;
                    break;
                }

                t += sdf;

                if (t >= MaxDistance)
                    break;
            }
        }

        return rad / float(NumDirections) * TAU;
    }

    stage override float4 Shading()
    {
        float2 uv = streams.TexCoord;
        float aspect = R.x / R.y;
        float pixelSize = 1.0 / max(R.x, R.y);
        float hitThreshold = pixelSize;
        float2 texelSize = 1.0 / R;

        float originSDF = Texture1.SampleLevel(Sampler0, uv, 0).r * SDFScale;

        // Interleaved spatial gather: each neighbor pixel traces rays with a
        // unique angular offset. Averaging them gives smooth results with
        // effectively (2*GatherRadius+1)^2 Ã— NumDirections total directions.
        float3 totalRadiance = 0;
        float totalWeight = 0;

        for (int gy = -GatherRadius; gy <= GatherRadius; gy++)
        {
            for (int gx = -GatherRadius; gx <= GatherRadius; gx++)
            {
                float2 neighborUV = uv + float2(gx, gy) * texelSize;
                float jitter = hash(neighborUV * R) * TAU;

                // Gaussian-ish weight: center pixel counts most
                float w = 1.0 / (1.0 + float(gx * gx + gy * gy));

                totalRadiance += TracePixel(neighborUV, aspect, pixelSize, hitThreshold, jitter) * w;
                totalWeight += w;
            }
        }

        totalRadiance /= totalWeight;

        // Blend direct emissive near surfaces
        float3 selfColor = Texture0.SampleLevel(Sampler0, uv, 0).rgb;
        float blend = saturate(3.0 - originSDF / pixelSize);
        totalRadiance = lerp(totalRadiance, selfColor * TAU, blend);

        // Tonemapping (matches shadertoy reference)
        totalRadiance *= Exposure;
        float3 mapped = 1.0 - 1.0 / pow(1.0 + totalRadiance, 2.5);

        return float4(mapped, 1.0);
    }
};
