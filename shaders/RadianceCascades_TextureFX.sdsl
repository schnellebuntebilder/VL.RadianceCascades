[TextureSource]

shader RadianceCascades_TextureFX : TextureFX
{
    // Texture0: Scene RGBA - RGB = emissive color
    // Texture1: SDF - signed distance field (positive = outside, <=0 = surface)

    float2 R = ViewSize;

    int NumDirections = 32;
    int MarchSteps = 16;
    int NumCascades = 4;
    float MaxDistance = 1.0;
    float SDFScale = 1.0;
    float Exposure = 1.0;
    float BlendWidth = 1.0;
    float RayOffset = 2.0;

    #define TAU 6.28318530718

    float hash(float2 p)
    {
        return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
    }

    // Snap UV to a coarse probe grid. Neighboring pixels that fall in
    // the same cell share the same probe origin → smooth far-field.
    float2 SnapToGrid(float2 uv, float cellPixels)
    {
        float2 cell = cellPixels / R;
        return (floor(uv / cell) + 0.5) * cell;
    }

    // Calculate cascade interval [start, end] — intervals grow by 4× per level
    float2 CascadeRange(int index)
    {
        float maxVal = float((1 << (NumCascades * 2)) - 1);
        float s = float((1 << (index * 2)) - 1);
        float e = float((1 << (index * 2 + 2)) - 1);
        return float2(s, e) / maxVal * MaxDistance;
    }

    stage override float4 Shading()
    {
        float2 uv = streams.TexCoord;
        float aspect = R.x / R.y;
        float pixelSize = 1.0 / max(R.x, R.y);
        float hitThreshold = pixelSize;

        float originSDF = Texture1.SampleLevel(Sampler0, uv, 0).r * SDFScale;

        float jitter = hash(uv * R) * TAU;

        float3 totalRadiance = 0;

        for (int d = 0; d < NumDirections; d++)
        {
            float angle = (float(d) + 0.5) / float(NumDirections) * TAU + jitter;
            float2 rd = normalize(float2(cos(angle) / aspect, sin(angle)));

            float3 radiance = 0;
            float visibility = 1.0;

            for (int c = 0; c < NumCascades; c++)
            {
                float2 range = CascadeRange(c);

                // Upper cascades use a coarser spatial grid — this is the
                // core radiance cascades idea: far light is sampled at low
                // spatial resolution and naturally interpolates smoothly.
                float cellSize = float(1 << c);
                float2 probeUV = c == 0 ? uv : SnapToGrid(uv, cellSize, R);

                float t = max(range.x, hitThreshold * RayOffset);

                for (int s = 0; s < MarchSteps; s++)
                {
                    float2 p = probeUV + t * rd;

                    if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)
                        break;

                    float sdf = Texture1.SampleLevel(Sampler0, p, 0).r * SDFScale;

                    if (sdf <= hitThreshold)
                    {
                        // Always sample color at mip 0 — no bleed through occluders
                        radiance += visibility * Texture0.SampleLevel(Sampler0, p, 0).rgb;
                        visibility = 0.0;
                        break;
                    }

                    t += sdf;

                    if (t >= range.y)
                        break;
                }

                if (visibility == 0.0)
                    break;
            }

            totalRadiance += radiance;
        }

        totalRadiance /= float(NumDirections);
        totalRadiance *= TAU;

        // Blend direct emissive near surfaces
        float3 selfColor = Texture0.SampleLevel(Sampler0, uv, 0).rgb;
        float blend = saturate(1.0 - originSDF * max(R.x, R.y) * BlendWidth);
        totalRadiance = lerp(totalRadiance, selfColor * TAU, blend);
        totalRadiance = max(totalRadiance, selfColor * TAU * blend * blend);

        // Tonemapping
        totalRadiance *= Exposure;
        float3 mapped = 1.0 - 1.0 / pow(1.0 + totalRadiance, 2.5);

        return float4(mapped, 1.0);
    }
};
